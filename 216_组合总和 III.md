## 题目
找出所有相加之和为 n 的 k 个数的组合，且满足下列条件：

只使用数字 1 到 9
每个数字 最多使用一次 
返回 所有可能的有效组合的列表 。该列表不能包含相同的组合两次，组合可以以任何顺序返回。

**示例 1**
```
输入：k = 3, n = 7
输出：[[1,2,4]]
解释：
1 + 2 + 4 = 7
没有其他符合的组合了。
```

**示例 2**
```
输入：k = 3, n = 9
输出：[[1,2,6], [1,3,5], [2,3,4]]
解释：
1 + 2 + 6 = 9
1 + 3 + 5 = 9
2 + 3 + 4 = 9
没有其他符合的组合了。
```

**示例 3**
```
输入：k = 4, n = 1
输出：[]
解释：不存在有效的组合。
在 [1,9] 范围内使用 4 个不同的数字，我们可以得到的最小和是 1+2+3+4 = 10，因为 10 > 1，没有有效的组合。
```

**提示**
* 2 <= k <= 9
* 1 <= n <= 60

## 代码
```Java
class Solution {
    private int[] nums = new int[]{1,2,3,4,5,6,7,8,9};
    private List<List<Integer>> result = new ArrayList<>();
    private int k;
    private int n;

    public List<List<Integer>> combinationSum3(int k, int n) {
        this.k = k;
        this.n = n;
        dfs(0, 0, new LinkedList<>());
        return result;
    }

    public void dfs(int currentIndex, int currentNum, LinkedList<Integer> path) {
        if(path.size() == k) {
            if(currentNum == n) {
                result.add(new ArrayList<>(path));
            }
            return;
        }
        for(int i = currentIndex;i < nums.length;i++) {
            path.add(nums[i]);
            dfs(i + 1, currentNum + nums[i], path);
            path.removeLast();
        }
    }
}
```
## 思路

经典回溯做法， 可以参考 [博客](https://labuladong.github.io/algo/1/9/) 套用模版。

时间复杂度为指数级。